class Boggle:
    def __init__(self, grid, dictionary):
        self.grid = grid
        self.setDictionary(dictionary)
        self.rows = len(grid)
        self.cols = len(grid[0]) if grid else 0
        self.solutions = []

    def setGrid(self, grid):
        self.grid = grid
        self.rows = len(grid)
        self.cols = len(grid[0]) if grid else 0
        self.solutions = []

    def setDictionary(self, dictionary):
        self.dictionary = set(word.upper() for word in dictionary)
        self.prefixes = set()
        for word in self.dictionary:
            for i in range(1, len(word)):
                self.prefixes.add(word[:i])
        self.solutions = []

    def getSolution(self):
        if not self.grid or not self.dictionary:
            return []

        self.solutions = []
        found_words = set()

        for r in range(self.rows):
            for c in range(self.cols):
                visited = [[False] * self.cols for _ in range(self.rows)]
                self._dfs(r, c, "", visited, found_words)

        self.solutions = sorted(found_words)
        return self.solutions

    def _dfs(self, r, c, current_word, visited, found_words):
        if r < 0 or r >= self.rows or c < 0 or c >= self.cols:
            return
        if visited[r][c]:
            return

        visited[r][c] = True
        letter = self.grid[r][c].upper()

        # Handle special tiles
        if letter == "QU":
            addition = "QU"
        elif letter == "ST":
            # Prevent ST immediately after another ST
            if current_word.endswith("ST"):
                visited[r][c] = False
                return
            addition = "ST"
        else:
            addition = letter

        current_word += addition

        # Stop exploring if word is absurdly long
        if len(current_word) > self.rows * self.cols * 2:
            visited[r][c] = False
            return

        # Prune early if not a prefix or word
        if current_word not in self.prefixes and current_word not in self.dictionary:
            visited[r][c] = False
            return

        # Only add valid words (>=3 chars) and not ending with forbidden letters
        if len(current_word) >= 3 and current_word in self.dictionary:
            if not (current_word.endswith("S") or current_word.endswith("I") or current_word.endswith("ST")):
                found_words.add(current_word)

        # Explore all directions
        for dr in [-1, 0, 1]:
            for dc in [-1, 0, 1]:
                if dr == 0 and dc == 0:
                    continue
                self._dfs(r + dr, c + dc, current_word, visited, found_words)

        visited[r][c] = False


def main():
    grid = [
        ["T", "W", "Y", "R"],
        ["E", "N", "P", "H"],
        ["G", "Z", "Qu", "R"],
        ["O", "N", "T", "A"]
    ]

    dictionary = [
        "art", "ego", "gent", "get", "net", "new", "newt", "prat", "pry",
        "qua", "quart", "quartz", "rat", "tar", "tarp", "ten", "went", "wet",
        "arty", "rhr", "not", "quar"
    ]

    game = Boggle(grid, dictionary)
    result = game.getSolution()
    print("Found words:", result)
    print(f"Total words found: {len(result)}")


if __name__ == "__main__":
    main()